; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	z:\sources\lunor\repos\rougemeilland\palmtree.math.core.sint\palmtree.math.core.sint\pmc_divrem.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_PMC_DivRem_X_X@16
PUBLIC	_PMC_DivRem_X_UX@16
PUBLIC	_PMC_DivRem_X_L@20
PUBLIC	_PMC_DivRem_X_I@16
PUBLIC	_PMC_DivRem_UX_X@16
PUBLIC	_PMC_DivRem_L_X@20
PUBLIC	_PMC_DivRem_I_X@16
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.sint\palmtree.math.core.sint\pmc_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.sint\palmtree.math.core.sint\pmc_memory.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.sint\palmtree.math.core.sint\pmc_divrem.c
;	COMDAT _PMC_DivRem_X_UX@16
_TEXT	SEGMENT
_r_abs$1 = 8						; size = 4
_u$ = 8							; size = 4
_result$2$ = 12						; size = 4
_nr$ = 12						; size = 4
_v$ = 12						; size = 4
_r_abs$2 = 16						; size = 4
_q_abs$3 = 16						; size = 4
_q$ = 16						; size = 4
_nq$ = 20						; size = 4
_r$ = 20						; size = 4
_PMC_DivRem_X_UX@16 PROC				; COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp

; 345  :     if (u == NULL)

	mov	eax, DWORD PTR _u$[ebp]
	push	edi
	test	eax, eax
	je	$LN31@PMC_DivRem

; 346  :         return (PMC_STATUS_ARGUMENT_ERROR);
; 347  :     if (v == NULL)

	mov	ecx, DWORD PTR _v$[ebp]
	test	ecx, ecx
	je	$LN31@PMC_DivRem

; 348  :         return (PMC_STATUS_ARGUMENT_ERROR);
; 349  :     if (r == NULL)

	mov	edi, DWORD PTR _r$[ebp]
	test	edi, edi
	je	$LN31@PMC_DivRem
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.sint\palmtree.math.core.sint\pmc_memory.c

; 197  :     if (p->SIGNATURE1 != PMC_SIGNATURE || p->SIGNATURE2 != PMC_SINT_SIGNATURE)

	cmp	DWORD PTR [eax+4], 1231244656		; 49634d70H
	jne	$LN28@PMC_DivRem
	cmp	DWORD PTR [eax+8], 1951287667		; 744e4973H
	jne	$LN28@PMC_DivRem
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.sint\palmtree.math.core.sint\pmc_divrem.c

; 357  :     if (v->FLAGS.IS_ZERO)

	test	BYTE PTR [ecx], 1
	je	SHORT $LN6@PMC_DivRem

; 358  :     {
; 359  :         // v == 0 ‚Ìê‡
; 360  : 
; 361  :         // ƒGƒ‰[‚ð•Ô‚·
; 362  :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3					; fffffffdH
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN6@PMC_DivRem:
	push	ebx

; 363  :     }
; 364  :     if (nu->SIGN == 0)

	mov	bl, BYTE PTR [eax+16]
	push	esi
	mov	esi, DWORD PTR _q$[ebp]
	test	bl, bl
	jne	SHORT $LN7@PMC_DivRem

; 365  :     {
; 366  :         // u == 0 ‚Ìê‡
; 367  : 
; 368  :         nq = q != NULL ? nq = &number_zero : NULL;
; 369  :         nr = &number_zero;

	xor	ecx, ecx
	mov	eax, OFFSET _number_zero
	test	esi, esi
	cmove	eax, ecx
	mov	ecx, OFFSET _number_zero

; 370  :     }

	jmp	$LN15@PMC_DivRem
$LN7@PMC_DivRem:

; 371  :     else
; 372  :     {
; 373  :         // u != 0 ‚Ìê‡
; 374  : 
; 375  :         if (q != NULL)

	mov	eax, DWORD PTR [eax+12]
	test	esi, esi
	je	$LN9@PMC_DivRem

; 376  :         {
; 377  :             char q_sign = nu->SIGN;
; 378  :             char r_sign = nu->SIGN;
; 379  :             PMC_HANDLE_UINT q_abs;
; 380  :             PMC_HANDLE_UINT r_abs;
; 381  :             if ((result = ep_uint.DivRem_X_X(nu->ABS, v, &q_abs, &r_abs)) != PMC_STATUS_OK)

	lea	edx, DWORD PTR _r_abs$1[ebp]
	push	edx
	lea	edx, DWORD PTR _q_abs$3[ebp]
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR _ep_uint+136
	test	eax, eax
	jne	SHORT $LN34@PMC_DivRem

; 382  :                 return (result);
; 383  :             if ((result = AllocateNumber(&nq, q_abs->FLAGS.IS_ZERO ? 0 : q_sign, q_abs)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _q_abs$3[ebp]
	lea	ecx, DWORD PTR _nq$[ebp]
	push	eax
	mov	edx, 0
	test	BYTE PTR [eax], 1
	movzx	eax, bl
	cmove	edx, eax
	call	_AllocateNumber
	add	esp, 4
	mov	DWORD PTR _result$2$[ebp], eax
	test	eax, eax
	je	SHORT $LN12@PMC_DivRem

; 384  :             {
; 385  :                 ep_uint.Dispose(q_abs);

	push	DWORD PTR _q_abs$3[ebp]
	call	DWORD PTR _ep_uint+16

; 386  :                 ep_uint.Dispose(r_abs);

	push	DWORD PTR _r_abs$1[ebp]
	call	DWORD PTR _ep_uint+16

; 387  :                 return (result);

	mov	eax, DWORD PTR _result$2$[ebp]
$LN34@PMC_DivRem:
	pop	esi
	pop	ebx
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN12@PMC_DivRem:

; 388  :             }
; 389  :             if ((result = AllocateNumber(&nr, r_abs->FLAGS.IS_ZERO ? 0 : r_sign, r_abs)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _r_abs$1[ebp]
	lea	ecx, DWORD PTR _nr$[ebp]
	push	eax
	mov	edx, 0
	test	BYTE PTR [eax], 1
	movzx	eax, bl
	cmove	edx, eax
	call	_AllocateNumber
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	SHORT $LN32@PMC_DivRem

; 390  :             {
; 391  :                 ep_uint.Dispose(q_abs);

	push	DWORD PTR _q_abs$3[ebp]
	call	DWORD PTR _ep_uint+16

; 392  :                 ep_uint.Dispose(r_abs);

	push	DWORD PTR _r_abs$1[ebp]
	call	DWORD PTR _ep_uint+16

; 393  :                 DeallocateNumber(nq);

	mov	ecx, DWORD PTR _nq$[ebp]
	call	_DeallocateNumber
	pop	esi

; 394  :                 return (result);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN32@PMC_DivRem:

; 388  :             }
; 389  :             if ((result = AllocateNumber(&nr, r_abs->FLAGS.IS_ZERO ? 0 : r_sign, r_abs)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _nq$[ebp]
	mov	ecx, DWORD PTR _nr$[ebp]
$LN15@PMC_DivRem:

; 408  :             }
; 409  :         }
; 410  :     }
; 411  :     if (q != NULL)

	test	esi, esi
	je	SHORT $LN16@PMC_DivRem

; 412  :         *q = (PMC_HANDLE_SINT)nq;

	mov	DWORD PTR [esi], eax

; 414  :     return (PMC_STATUS_OK);

	xor	eax, eax
	pop	esi
	pop	ebx
	mov	DWORD PTR [edi], ecx
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN9@PMC_DivRem:

; 395  :             }
; 396  :         }
; 397  :         else
; 398  :         {
; 399  :             char r_sign = nu->SIGN;
; 400  :             PMC_HANDLE_UINT r_abs;
; 401  :             if ((result = ep_uint.DivRem_X_X(nu->ABS, v, NULL, &r_abs)) != PMC_STATUS_OK)

	lea	edx, DWORD PTR _r_abs$2[ebp]
	push	edx
	push	0
	push	ecx
	push	eax
	call	DWORD PTR _ep_uint+136
	test	eax, eax
	jne	SHORT $LN34@PMC_DivRem

; 402  :                 return (result);
; 403  :             nq = NULL;
; 404  :             if ((result = AllocateNumber(&nr, r_abs->FLAGS.IS_ZERO ? 0 : r_sign, r_abs)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _r_abs$2[ebp]
	lea	ecx, DWORD PTR _nr$[ebp]
	push	eax
	mov	edx, 0
	test	BYTE PTR [eax], 1
	movzx	eax, bl
	cmove	edx, eax
	call	_AllocateNumber
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN33@PMC_DivRem

; 405  :             {
; 406  :                 ep_uint.Dispose(r_abs);

	push	DWORD PTR _r_abs$2[ebp]
	call	DWORD PTR _ep_uint+16

; 407  :                 return (result);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN33@PMC_DivRem:

; 402  :                 return (result);
; 403  :             nq = NULL;
; 404  :             if ((result = AllocateNumber(&nr, r_abs->FLAGS.IS_ZERO ? 0 : r_sign, r_abs)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _nr$[ebp]
$LN16@PMC_DivRem:
	pop	esi
	pop	ebx

; 413  :     *r = (PMC_HANDLE_SINT)nr;

	mov	DWORD PTR [edi], ecx

; 414  :     return (PMC_STATUS_OK);

	xor	eax, eax
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN28@PMC_DivRem:

; 351  :     PMC_STATUS_CODE result;
; 352  :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
; 353  :     NUMBER_HEADER* nq;
; 354  :     NUMBER_HEADER* nr;
; 355  :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)
; 356  :         return (result);

	mov	eax, -257				; fffffeffH
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
$LN31@PMC_DivRem:

; 350  :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	pop	edi

; 415  : }

	pop	ebp
	ret	16					; 00000010H
_PMC_DivRem_X_UX@16 ENDP
_TEXT	ENDS
END
